#!/usr/bin/python3

"""
== Лото ==

Правила игры в лото.

Игра ведется с помощью специальных карточек, на которых отмечены числа,
и фишек (бочонков) с цифрами.

Количество бочонков — 90 штук (с цифрами от 1 до 90).

Каждая карточка содержит 3 строки по 9 клеток. В каждой строке по 5 случайных цифр,
расположенных по возрастанию. Все цифры в карточке уникальны. Пример карточки:

--------------------------
    9 43 62          74 90
 2    27    75 78    82
   41 56 63     76      86 
--------------------------

В игре 2 игрока: пользователь и компьютер. Каждому в начале выдается 
случайная карточка. 

Каждый ход выбирается один случайный бочонок и выводится на экран.
Также выводятся карточка игрока и карточка компьютера.

Пользователю предлагается зачеркнуть цифру на карточке или продолжить.
Если игрок выбрал "зачеркнуть":
	Если цифра есть на карточке - она зачеркивается и игра продолжается.
	Если цифры на карточке нет - игрок проигрывает и игра завершается.
Если игрок выбрал "продолжить":
	Если цифра есть на карточке - игрок проигрывает и игра завершается.
	Если цифры на карточке нет - игра продолжается.
	
Побеждает тот, кто первый закроет все числа на своей карточке.

Пример одного хода:

Новый бочонок: 70 (осталось 76)
------ Ваша карточка -----
 6  7          49    57 58
   14 26     -    78    85
23 33    38    48    71   
--------------------------
-- Карточка компьютера ---
 7 87     - 14    11      
      16 49    55 88    77    
   15 20     -       76  -
--------------------------
Зачеркнуть цифру? (y/n)

Подсказка: каждый следующий случайный бочонок из мешка удобно получать 
с помощью функции-генератора.

Подсказка: для работы с псевдослучайными числами удобно использовать 
модуль random: http://docs.python.org/3/library/random.html

"""
import random
import sys
import time

class Cask:
    # класс Бочёнок для выдачи требуемого количества значений в нужном диапазоне
    def f(self):
        lst = [x for x in range(1, self.amount + 1)] # генерируем список значений от 1 до заданного пользователем
        random.shuffle(lst)     # перемешиваем значения в списке случайным образом
        for i, y in enumerate(lst): # проходим по i-му индексу нумерованного списка со значениями этих элементов y
            print('{:*^30}'.format('*'))    # маркер автозаполнения
            print('Новый бочонок: {} (осталось {})'.format(y, self.amount - (i + 1))) # информирование о текущем значении и оставшемся кол-ве
            yield y # возврат значения нового бочёнка в игру

    def __init__(self, amount):
        self.amount = amount    # количество бочёноков, задаваемое для игрового процесса
        self.gen = self.f()     # имя в классе для передачи итерируемого значения нового бочёнка


class Loto:
    # Нарезаем карточки
    def __set_card(self):
        num = set()
        while len(num) < self.all_row * 5: # если текущая длина множества меньше всего количества рядов умноженного на пять обязательных чисел в ряду
            num.add(random.randint(1, 91)) # добавляем случайное число во множество, пока не заполним
        cards = list(num)   # передаём данные в карточки в виде списка
        random.shuffle(cards) # перемешиваем данные в карточках

        while len(cards) % self.all_row != 0: # цикл будет исполняться пока остаток от деления от общего количества строк в карточках на всего рядов не будет делится без остатка
            cards.append('None')
        self.all_row = int(len(cards) / self.all_row)
        # формируем ряды карточек из имеющегося списка: создаём списки в списках через срезы от i до длины всего списка с шагом all_row
        cards = [cards[i: i + self.all_row] for i in range(0, len(cards), self.all_row)]

        # сортируем значения во всех рядах карточек
        for i in range(len(cards)):
            cards[i].sort()
        self.card_user = cards[:3]  # закрепляем первые три ряда за пользователем
        self.card_comp = cards[3:]  # закрепляем последние три ряда за компьютером

    def __init__(self, amount_card): # конструктор с указанием количества игровых карточек
        row = 3 # указываем, что в одной карточке по три ряда значенией
        self.all_row = row * amount_card # всего рядов по кол-ву игроков, в нашем случае 3 ряда * 2 карточки = всего 6
        self.__set_card() # заполняем карточки

    def get_card(self, card_player):
        '''
        метод вывода карточки в определенном формате
        '''
        print('{:-^25}'.format(self.name)) # имя участника и заполняющий маркер
        print('{0[0]:>2} {0[1]:<10} {0[2]:<5} {0[3]} {0[4]} '.format(card_player[0])) # первый ряд значений карточки
        print('{0[0]:>4} {0[1]:<6} {0[2]:<4} {0[3]:<4} {0[4]} '.format(card_player[1])) # второй ряд значений карточки
        print('{0[0]} {0[1]:<5} {0[2]:<5} {0[3]:<5} {0[4]} '.format(card_player[2])) # третий ряд значений карточки
        print('{:-^25}'.format('-')) # закрывающий заполняющий маркер

    # Поиск номера на карточке и определение победителя
    def search(self, card_player, num_cask):
        '''
        Метод проверки номера в карточке участника и определение победителя по счёту закрытых чисел в карточке
        Карточка значений и номер бочёнка передаются в метод
        '''
        for i, n in enumerate(card_player): # перебираем строки карточки i и порядковые номера значений в них
            if num_cask in n:   # если текущий номер бочёнка присутствует в одном из значений строки
                card_player[i][n.index(num_cask)] = '-' # зачеркнуть найденное значение
                self.score += 1     # увеличить счётчик вычеркнутых значений
                if self.score == 15:    # если кол-во зачеркнутых значение 15, значит все числа вычеркнуты
                    print('{} Победила!'.format(self.name)) # объявляем, что участник 'name' победил
                    sys.exit(1) # делаем искусственное прерывание программы
                return True # возвращаем истину, если операция зачеркивания совершена
        return False    # возвращаем ложь, если поиск номера был инициирован, но числа в карточке не оказалось

# объявляем класс участника, наследующий класс Loto
class Player(Loto):

    def __init__(self, name):
        self.name = name    # инициирует исходное имя участника в экземпляре класса
        self.score = 0      # устанавливает исходное значение кол-ва вычеркнутых значений в карточке


def main():
    '''
    Ключевая функции игры, которая объединяет в себе основную игровую логику
    '''
    game = Loto(2) # создаём экземпляр класса для работы с карточками
    cask = Cask(90) # запускаем экземпляр класса, который будет перебирать значения бочёнка
    player1 = Player('Ваша карточка')   # создаём экземпляр класса первого игрока
    player2 = Player('Карточка компьютера') # создаём экземпляр класса второго игрока

    while True:     # бесконечный игровой цикл
        num_cask = next(cask.gen)   # получаем следующее значение из итератора Бочёнок
        player1.get_card(game.card_user)    # выводим на экран карточку пользователя
        player2.get_card(game.card_comp)    # выводим на экран карточку компьютера

        inp_user = input('Зачеркнуть цифру? (y/n)') # уточняем у пользователя наличие номера и ждём подтверждения
        if inp_user == 'y': # если пользователь утверждает, что значение у него в карточке есть
            if player1.search(game.card_user, num_cask):    # то запускаем проверку истинности наличия у него в карточке значения
                continue                    # если значение было найдено, то вычеркиваем и продолжаем игру
            else:           # если пользователь ошибся и наличие числа не подтвердилось - это обман и по правилам игры он проигрывает
                print('Game Over')  # радуем ))
                sys.exit(1)         # искусственно прерываем программу
        if inp_user == 'n':         # если пользователь считает, что значения бочёнка в карточке нет
            if player1.search(game.card_user, num_cask):    # проверяем наличие значения
                print('Game Over')  # если он ошибся, значит не внимательный - по правилам игры проигрывает
                sys.exit(1)         # искусственно прервываем программу
            elif player2.search(game.card_comp, num_cask):  # если в карточке компьютера есть значение, вычеркиваем и продолжаем
                continue
        if inp_user != 'n' and inp_user != 'y': # если пользователь опечатался и указал другое значение ввода, то повторяем запрос
            print('Введите y or n')
            time.sleep(1)   # приостановление выполнения программы на 1 секунду и продолжаем
            continue


# вызов ключевой функции игры производим только в случае, если запускается текущий скрипт, а не импортируется в другой скрипт
if __name__ == '__main__':
    main()
